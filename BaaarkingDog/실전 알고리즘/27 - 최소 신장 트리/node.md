## 프림(Prim) 알고리즘
- 우선순의 큐를 가지고 구현
- 한 정점에서 시작해 확장해나가는 개념
```
1. 임의의 정점을 선택해 최소 신장 트리에 추가
3. 최소 신장 트리에 포함된 정점과 최소 신장 트리에 포함되지 않은 정점을 연결하는 간성 중
비용이 가장 작은 것을 최소 신장 트리에 추가
3. 최소 신장 트리에 v-1개의 간선이 추가될 때 까지 2번 과정을 반복
```
```
하나의 정점에서 시작, 매번 가장 낮은 비용의 간선을 찾아 뻗어 나가는 방식

1. 임의의 정점을 선택해 최소 신장 트리에 추가.
해당 정점과 연결된 모든 간선을 우선순위 큐에 추가.
2. 우선순위 큐에서 비용이 가장 작은 간선을 선택
3. 만약 해당 간선이 최소 신장 트리에 포함된 두 정점을 연결한다면 아무 것도 하지 않고 넘어감.
해당 간선이 최소 신장 트리에 포함된 정점 u와 포함되지 않은 정점 v를 연결한다면 해당 간선과 정점 v를
최소 신장 트리에 추가 후 정점 v와 최소 신장 트리에 포함되지 않는 정점을 연결하는 모든 간선을 
우선순위 큐에 추가.
4. 최소 신장 트리에 v-1개의 간선이 추가될 때 까지 2,3번 과정을 반복
```
```c++
#define X first
#define Y second

int v,e
vector<pair<int,int>> adj[10005]; // <비용,정점번호>
bool check[10005]; // check[i]는 i번째 정점이 최소신장트리에 포함되었는지 여부를 체크
priority_queue< tuple<int,int,int>,
                vector<tuple<int,int,int>>,
                greater<tuple<int,int,int>> >pq;
// 최소신장트리에서는 최소힙이 필요하다.
// tuple < 비용, 정점1, 정점2 >
int cnt = 0; // 현재 선택된 간선의 수

check[1] = 1;
for(auto nxt: adj[1])
  pq.push({nxt.X, 1, nxt.Y});
 
while(cnt<v-1){
  int cost, a, b;
  tie(cost,a,b) = pq.top(); pq.pop(); 
  // tie pair, tuple으로 묶인 녀석들을 던저서 여러 변수에 한번에 받아 올 수 있습니다.
  if(check[b]) continue;
  cout<<cost<<' '<<a<<' '<<b<<'\n';
  check[b] = 1;
  cnt++;
  for(auto nxt:adj[b]){
    if(!check[nxt.Y])
      pq.push({nxt.X, b, nxt.Y});
  }
}

우선순위큐에 값을 넣을 때에는 
현재 최소신장트리에 속하지 않은 정점의 번호를
가장 마지막에 가도록 했기 때문에
check[a]는 반드시 true
그래서 현재 보고 있는 간선이 최소신장트리에 포함된 두 정점을 연결한 간선인지
최소신장트리에 포함된 정점과, 포함되지 않은 정점을 연결한 간선인지 판단하기 위해서
check[b]만 확인하면 된다.
```
## 크루스칼(Kruskal) 알고리즘


### MST
모든 노드를 연결하는데, 그걸 최소 비용(가중치)으로 하겠다.<br/>
ex) A,B,C 건물에 랜선을 깔건데,<br/>
굳이 A,B,C가 모두 연결되게끔 설치할 필요가 없다.(A-B,A-C,B-C)<br/>
A-B-C 이렇게 선형으로만 연결시켜도 통신이 된다.<br/>

