### 플로이드 알고리즘
모든 정점 쌍 사이 각각의 최단 거리를 구하는 알고리즘

```c++
void floyd()
{
  // i : source
  // j : destination
  // k : mid
  for(int k=1;k<=n;k++)
    for(int i=1;i<=n;i++)  
      for(int j=1;j<=n;j++)
        if(d[i][k]+d[k][j]<d[i][j]) d[i][j] = d[i][k] + d[k][j]
}
```
```
1번 정점을 거쳐서 가는 최단거리비용
2번 정점을 거쳐서 가는 최단거리비용
...
n번 정점을 거쳐서 가는 최단거리비용
```

```
bfs/dfs 등 각 정점에 대해 그 정점과 연결된 다른 정점 목록을 보는 알고리즘은
그래프를 인접리스트 형식으로 나타내는게 유리하지만

플로이드 알고리즘의 경우
테이블의 형태 자체가 인접행렬 방식이기 때문에
인접행렬로 그래프를 표현해준다.

플로이드 알고리즘 구현 시
시작:i,끝:j,중간지점:k
항상 k를 돌리는 for문을 바깥에 써줘야 한다.
알고리즘 자체가 중간을 거쳐가는 정점을 기준으로 생각해야하기 때문



보통 연산보다 대입이 느리기 때문에
플로이드 알고리즘처럼 대입이 엄청나게 일어나는 알고리즘에서는
min max 함수를 이용해서 불필요한 대입을 하는 것 보다
if로 분기를 해서 필요한 경우에만 대입할 수 있도록 하는 것이
상수시간 최적화를 만들 수 있는 방법이다.
if(d[i][k]+d[k][j]<d[i][j]) d[i][j] = d[i][k] + d[k][j]

d[i][j] 중간 정점을 거치지 않고 가는 거리 비용
d[i][k]+d[k][j] 중간 정점 k를 거쳐서 가는 거리 비용

```
